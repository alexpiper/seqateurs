library(seqateurs)
?utils
?rvest
?processx
?processx
processx
processx::run()
?processx::run
?by
?tstrsplit
?Reduce
?stringdist
?stringdist::stringdist
library(seqateurs)
librblast_top_hit(return))
?taxreturn:blast_top_hit
?taxreturn:blast_top_hit
?taxreturn::blast_top_hit
library(seqateurs)
#' @param dest.dir (Optional)  Default "bin"
#' Directory to install bbmap within.
#' @force Whether existing installs should be forcefully overwritten
#'
#'
#' @return
#' @export
#'
#' @import httr
#' @examples
bbmap_install <- function(url, dest.dir = "bin", force = FALSE) {
if (missing(url)) {
url <- ("https://sourceforge.net/projects/bbmap/files/latest/download")
}
if (!dir.exists(dest.dir)) {
dir.create(dest.dir) # Create first directory
}
if (dir.exists(paste0(dest.dir, "/bbmap")) && force == FALSE) {
message("Skipped as bbmap already exists in directory, to overwrite set force to TRUE")
return(NULL)
} else  if (dir.exists(paste0(dest.dir, "/bbmap")) && force == TRUE) {
unlink(paste0(dest.dir, "/bbmap"), recursive = TRUE) # Remove old version
}
destfile <- paste0(file.path(dest.dir, basename(url)),".tar.gz")
if (file.exists(destfile)) {
file.remove(destfile) # Remove old zip file
}
#Download file
httr::GET(url, httr::write_disk(destfile, overwrite=TRUE))
#Unzip
utils::untar(destfile, exdir = dest.dir)
#Remove download
file.remove(destfile)
}
#' path <- "run_test/"
#'
#' fastqFs <- sort(list.files(path, pattern="R1_001.*", full.names = TRUE))
#' fastqRs <- sort(list.files(path, pattern="R2_001.*", full.names = TRUE))
#'
#'bbtrim(install="bin/bbmap", fwd=fastqFs, rev=fastqRs,
#' primers=c("GGDACWGGWTGAACWGTWTAYCCHCC","GTRATWGCHCCDGCTARWACWGG"),
#'  degenerate=TRUE, out.dir="trimmed", ktrim="left", ordered=TRUE,
#'   mink=FALSE, hdist=2, maxlength=140, overwrite=TRUE)
#'}
bbtrim <- function(install = NULL, fwd, rev = NULL, primers,
restrictleft = NULL, out.dir = "bbduk", trim.end = "left", ordered = TRUE,
kmer = NULL, mink = FALSE, tpe = TRUE, hdist = 0, degenerate = TRUE,
overwrite = TRUE, quality = FALSE, maxlength = NULL, tmp=NULL) {
nsamples <- length(fwd)
# Create temp files
if(is.null(tmp)) {tmp <- tempdir()}
tmplogs <- paste0(tmp, "/bbtrim.log")
if(file.exists(tmplogs)) { file.remove(tmplogs)}
bbduk <- function(install = NULL, fwd, rev = NULL, primers,
restrictleft = NULL, out.dir = "bbduk", trim.end = "left", ordered = TRUE,
kmer = NULL, mink = FALSE, tpe = TRUE, hdist = 0, degenerate = TRUE,
overwrite = TRUE, quality = FALSE, maxlength = NULL, tmp=NULL) {
install <- paste0(install, "/current jgi.BBDuk")
# Create temp files
if(is.null(tmp)) {tmp <- tempdir()}
tmplogs <- paste0(tmp, "/bbtrim.log")
tmpout <- paste0(tmp,"/stdout.log")
tmperr <- paste0(tmp,"/stderr.log")
in1 <- paste0("in=", fwd)
if (!is.null(rev)) {
in2 <- paste0("in2=", rev)
} else {
(in2 <- "")
}
if (!is.null(primers)) {
literal <- paste0("literal=", paste0(primers, collapse = ","))
} else {
(stop("Primer sequences are required for trimming"))
}
if (is.null(rev)) {
out <- paste0(
"out=", dirname(fwd), "/", out.dir, "/", basename(fwd)
) %>%
stringr::str_replace(pattern = ".fastq", replacement = ".trimmed.fastq")
out1 <- ""
out2 <- ""
} else if (!is.null(rev)) {
out <- ""
out1 <- paste0("out1=", dirname(fwd), "/", out.dir, "/", basename(fwd)) %>%
stringr::str_replace(pattern = ".fastq", replacement = ".trimmed.fastq")
out2 <- paste0("out2=", dirname(rev), "/", out.dir, "/", basename(rev)) %>%
stringr::str_replace(pattern = ".fastq", replacement = ".trimmed.fastq")
}
if (trim.end == "left") {
trim.end <- paste0("ktrim=l")
} else if (trim.end == "right") {
trim.end <- paste0("ktrim=r")
}
if (is.numeric(kmer)) {
kmer <- paste0("k=", kmer)
} else {
(kmer <- paste0("k=", sort(nchar(primers), decreasing = FALSE)[1]))
}
if (is.numeric(maxlength)) {
maxlength <- paste0("maxlength=", maxlength)
} else {
maxlength <- ""
}
if (is.numeric(mink)) {
mink <- paste0("mink=", mink) # Note - mink makes it noticibly slower
} else if (mink == TRUE) {
mink <- paste0("mink=", (sort(nchar(primers), decreasing = FALSE)[1] / 2))
} else if (mink == FALSE) {
mink <- ""
}
if (is.numeric(restrictleft)) {
restrictleft <- paste0("restrictleft=", restrictleft)
} else {
restrictleft <- paste0("restrictleft=", sort(nchar(primers), decreasing = TRUE)[1])
}
if (ordered == TRUE) {
ordered <- "ordered=T"
} else {
(ordered <- "")
}
if (is.numeric(hdist)) {
hdist <- paste0("hdist=", hdist)
}
if (degenerate == TRUE) {
degenerate <- "copyundefined"
} else {
(degenerate <- "")
}
if (overwrite == TRUE) {
overwrite <- "overwrite=TRUE"
} else {
(overwrite <- "")
}
if (tpe == TRUE) {
tpe <- "tpe"
} else {
(tpe <- "")
}
# Set up quality tracking
if (quality == TRUE) {
qualnames <- fwd %>% str_replace(pattern=".fastq.gz", replacement="") %>%
basename
qualnames <- paste0(tmp,"/", qualnames)
quality <-
paste0("bhist=", qualnames, "_bhist.txt ",
"qhist=", qualnames, "_qhist.txt ",
"gchist=", qualnames, "_gchist.txt ",
"aqhist=", qualnames, "_aqhist.txt ",
"lhist=", qualnames, "_lhist.txt ",
"gcbins=auto ")
} else {
(quality <- "")
}
args <- paste(" -cp ", install, in1, in2, literal, restrictleft, out, out1,
out2, kmer, mink, hdist, trim.end, tpe, degenerate, quality,
maxlength, overwrite, "-da",
collapse = " "
)
# Run bbduk
result <- system2(command="java",
args = args,
stdout = tmpout,
stderr = tmperr,
wait=TRUE)
now <- date()
cat(paste0("Executed: ", now, "\n"), file = tmplogs, append=TRUE)
cat(paste0("Sample:\t", fwd, "\n"), file = tmplogs, append=TRUE)
file.append(tmplogs, tmperr)
file.remove(c(tmpout, tmperr))
}
if (nsamples > 1) {
for (i in 1:nsamples) {
bbduk(install = install, fwd = fwd[i], rev = rev[i],
primers = primers, restrictleft = restrictleft,
out.dir = out.dir, trim.end = trim.end, ordered = ordered,
kmer = kmer, mink = mink, tpe = tpe, hdist = hdist,
degenerate = degenerate, quality = quality,
overwrite = overwrite, maxlength = maxlength, tmp=tmp)
}
} else if (nsamples == 1) {
bbduk(install = install, fwd = fwd, rev = rev,
primers = primers, restrictleft = restrictleft,
out.dir = out.dir, trim.end = trim.end, ordered = ordered,
kmer = kmer, mink = mink, tpe = tpe, hdist = hdist,
degenerate = degenerate, quality = quality,
overwrite = overwrite, maxlength = maxlength, tmp=tmp)
}
#Parse logs
parsed <- parse_bbtrim(tmplogs)
if (quality == TRUE) {
#Base composition histogram by position.
bhist <- parse_bhist(tmp)
#Quality histogram by position.
qhist <- parse_qhist(tmp)
#Histogram of average read quality. - how does this work with binned qscores?
aqhist <- parse_aqhist(tmp)
#Read GC content histogram. - is it worth just reading in the top 4 lines?
gchist <- parse_aqhist(tmp)
#Read length histogram.
lhist <- parse_lhist(tmp)
out <- list(parsed,
bhist,
qhist,
aqhist,
gchist,
lhist)
names(out) <- c("reads", "bp_freq", "quality","avg_quality","gc","length")
} else (out <- parsed)
return(out)
}
library(seqateurs)
install="bin/bbmap"
fwd <- "Syn1-007_S7_L001_R1_001.fastq.gz"
rev <- "Syn1-007_S7_L001_R2_001.fastq.gz"
rev <- "Syn1-008_S8_L001_R2_001.fastq.gz"
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
if(!quiet) {message(paste0("Trimming primers from: ", fwd, " and ", rev))}
# Create temp files
if(is.null(tmp)) {tmp <- tempdir()}
tmp <- NULL
# Create temp files
if(is.null(tmp)) {tmp <- tempdir()}
tmplogs <- paste0(tmp, "/bbtrim.log")
tmpout <- paste0(tmp,"/stdout.log")
tmperr <- paste0(tmp,"/stderr.log")
in1 <- paste0("in=", fwd)
if (!is.null(rev)) {
in2 <- paste0("in2=", rev)
} else {
(in2 <- "")
}
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
reformat_args
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout=tmpout,
stderr=tmperr,
wait=TRUE)
result
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout="testout",
stderr="testerr",
wait=TRUE)
library(seqateurs)
bbmap_install()
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout="testout",
stderr="testerr",
wait=TRUE)
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout="testout.txt",
stderr="testerr.txt",
wait=TRUE)
fwd
rev
rev <- "Syn1-007_S7_L001_R2_001.fastq.gz"
in1 <- paste0("in=", fwd)
if (!is.null(rev)) {
in2 <- paste0("in2=", rev)
} else {
(in2 <- "")
}
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout="testout.txt",
stderr="testerr.txt",
wait=TRUE)
result
?system2
# Run Reformatreads
result <- system2(command="java",
args = reformat_args,
stdout="",
stderr="",
wait=TRUE)
result
result
?processx
?processx::base64_decode
result <- processx::run(command="java",
args = reformat_args,
echo=TRUE,
echo_cmd	= TRUE,
spinner=TRUE,
windows_verbatim_args=TRUE,
error_on_status = FALSE,
cleanup_tree = TRUE)
result
result <- processx::run(command="java",
args = reformat_args,
echo=FALSE,
echo_cmd	= FALSE,
spinner=TRUE,
windows_verbatim_args=TRUE,
error_on_status = FALSE,
cleanup_tree = TRUE)
result
result$stderr
fwd
rev
rev <- "Syn1-009_S9_L001_R1_001.fastq.gz"
in1 <- paste0("in=", fwd)
if (!is.null(rev)) {
in2 <- paste0("in2=", rev)
} else {
(in2 <- "")
}
reformat_args <- paste(" -cp ", paste0(install, "/current jgi.ReformatReads "), in1, in2, "vpair", collapse = " ")
result <- processx::run(command="java",
args = reformat_args,
echo=FALSE,
echo_cmd	= FALSE,
spinner=TRUE,
windows_verbatim_args=TRUE,
error_on_status = FALSE,
cleanup_tree = TRUE)
result$stderr
str_detect(result$stderr, "Names do not appear to be correctly paired.")
stringr::str_detect(result$stderr, "Names do not appear to be correctly paired.")
library(seqateurs)
library(seqateurs)
library(seqateurs)
library(seqateurs)
library(seqateurs)
library(seqateurs)
library(seqateurs)
library(seqateurs)
?bind_cols
library(seqateurs)
?IdClusters
library(seqateurs)
